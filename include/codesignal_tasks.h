
#ifndef _CODE_SIGNAL_TASKS_H_
#define _CODE_SIGNAL_TASKS_H_

#include <vector>
#include <unordered_map>
#include <climits>

namespace codesignal_tasks {

/*
Given an integer n and an array a of length n, your task is to apply the following mutation to a:

Array a mutates into a new array b of length n.
For each i from 0 to n - 1, b[i] = a[i - 1] + a[i] + a[i + 1].
If some element in the sum a[i - 1] + a[i] + a[i + 1] does not exist, it should be set to 0. For example, b[0] should be equal to 0 + a[0] + a[1].
Example

For n = 5 and a = [4, 0, 1, -2, 3], the output should be mutateTheArray(n, a) = [4, 5, -1, 2, 1].

b[0] = 0 + a[0] + a[1] = 0 + 4 + 0 = 4
b[1] = a[0] + a[1] + a[2] = 4 + 0 + 1 = 5
b[2] = a[1] + a[2] + a[3] = 0 + 1 + (-2) = -1
b[3] = a[2] + a[3] + a[4] = 1 + (-2) + 3 = 2
b[4] = a[3] + a[4] + 0 = (-2) + 3 + 0 = 1
So, the resulting array after the mutation will be [4, 5, -1, 2, 1].

Input/Output

[execution time limit] 0.5 seconds (cpp)

[input] integer n

An integer representing the length of the given array.

Guaranteed constraints:
1 ≤ n ≤ 103.

[input] array.integer a

An array of integers that needs to be mutated.

Guaranteed constraints:
a.length = n,
-103 ≤ a[i] ≤ 103.

[output] array.integer

The resulting array after the mutation.

[C++] Syntax Tips

// Prints help message to the console
// Returns a string
string helloWorld(string name) {
    cout << "This prints to the console when you Run Tests" << endl;
    return "Hello, " + name;
}

*/
std::vector<int> mutateTheArray(int n, std::vector<int> a) {
    std::vector<int> b(n, 0);
    for(size_t i=0; i<n; ++i) {
        b[i] = a[i];
        if(i > 0) {
            b[i] += a[i-1];
        }
        if(i < (n-1)) {
            b[i] += a[i+1];
        }
    }
    
    return b;
}

/*
You are given an array of integers a. A new array b is generated by rearranging the elements of a in the following way:

b[0] is equal to a[0];
b[1] is equal to the last element of a;
b[2] is equal to a[1];
b[3] is equal to the second-last element of a;
b[4] is equal to a[2];
b[5] is equal to the third-last element of a;
and so on.
Here is how this process works:



Your task is to determine whether the new array b is sorted in strictly ascending order or not.

Example

For a = [1, 3, 5, 6, 4, 2], the output should be alternatingSort(a) = true.

The new array b will look like [1, 2, 3, 4, 5, 6], which is in strictly ascending order, so the answer is true.

For a = [1, 4, 5, 6, 3], the output should be alternatingSort(a) = false.

The new array b will look like [1, 3, 4, 6, 5], which is not in strictly ascending order, so the answer is false.

Input/Output

[execution time limit] 0.5 seconds (cpp)

[input] array.integer a

The given array of integers.

Guaranteed constraints:
1 ≤ a.length ≤ 105,
-109 ≤ a[i] ≤ 109.

[output] boolean

A boolean representing whether the new array b will be sorted in strictly ascending order or not.

[C++] Syntax Tips

// Prints help message to the console
// Returns a string
string helloWorld(string name) {
    cout << "This prints to the console when you Run Tests" << endl;
    return "Hello, " + name;
}
*/
bool alternatingSort(std::vector<int> a) {
    // stricty sort => a[i-1] < a[i] < a[i+1]
    auto size = a.size();
    
    if(size < 2) {
        return true;
    }
 
    int lastVisitedValue = INT_MIN; 
    for(size_t i=0; i<size/2; ++i) {
        if(lastVisitedValue >= a[i]) {
            return false;
        }
        if(a[i] >= a[size-1-i]) {
            return false;
        }
        lastVisitedValue = a[size-1-i];
    }
    
    if(size % 2 == 1) { // control the element in the middle
        if(lastVisitedValue >= a[size/2]) {
            return false;
        }
    }
    
    return true;
}

/*
You are implementing your own programming language and you've decided to add support for merging strings. A typical merge function would take two strings s1 and s2, and return the lexicographically smallest result that can be obtained by placing the symbols of s2 between the symbols of s1 in such a way that maintains the relative order of the characters in each string.

For example, if s1 = "super" and s2 = "tower", the result should be merge(s1, s2) = "stouperwer".



You'd like to make your language more unique, so for your merge function, instead of comparing the characters in the usual lexicographical order, you'll compare them based on how many times they occur in their respective initial strings (fewer occurrences means the character is considered smaller). If the number of occurrences are equal, then the characters should be compared in the usual lexicographical way. If both number of occurences and characters are equal, you should take the characters from the first string to the result. Note that occurrences in the initial strings are compared - they do not change over the merge process.

Given two strings s1 and s2, return the result of the special merge function you are implementing.

Example

For s1 = "dce" and s2 = "cccbd", the output should be
mergeStrings(s1, s2) = "dcecccbd".
All symbols from s1 goes first, because all of them have only 1 occurrence in s1 and c has 3 occurrences in s2.



For s1 = "super" and s2 = "tower", the output should be
mergeStrings(s1, s2) = "stouperwer".
Because in both strings all symbols occur only 1 time, strings are merged as usual. You can find explanation for this example on the image in the description.

Input/Output

[execution time limit] 0.5 seconds (cpp)

[input] string s1

A string consisting only of lowercase English letters.

Guaranteed constraints:
1 ≤ s1.length ≤ 104.

[input] string s2

A string consisting only of lowercase English letters.

Guaranteed constraints:
1 ≤ s2.length ≤ 104.

[output] string

The string that results by merging s1 and s2 using your special merge function.

[C++] Syntax Tips

// Prints help message to the console
// Returns a string
string helloWorld(string name) {
    cout << "This prints to the console when you Run Tests" << endl;
    return "Hello, " + name;
}

*/
std::string mergeStrings(std::string s1, std::string s2) {
    auto sizeS1 = s1.size();
    auto sizeS2 = s2.size();
    
    std::unordered_map<char, int> mapS1;
    std::unordered_map<char, int> mapS2;
    
    // calculating the occurrences
    for(size_t i=0; i<sizeS1; ++i) {
        ++mapS1[s1[i]];
    }
    
    // calculating the occurrences
    for(size_t i=0; i<sizeS2; ++i) {
        ++mapS2[s2[i]];
    }
    
    std::string merged{""};
    auto i = 0;
    auto j = 0;
    while(i<sizeS1 && j<sizeS2) {
        auto s1C = s1[i];
        auto s2C = s2[j];
        
        // compare the occurrences of respective chars
        if(mapS1[s1C] < mapS2[s2C]) {
            merged.push_back(s1C);
            ++i;
        } else if(mapS1[s1C] > mapS2[s2C]) { // char at s2 occurs less!
            merged.push_back(s2C);
            ++j;
        } else {
            // compare the lexicographical order
            if(s1C < s2C) {
                merged.push_back(s1C);
                ++i;
            } else if(s1C > s2C) { // char at s2 is smaller
                merged.push_back(s2C);
                ++j;
            } else {
                merged.push_back(s1C);
                ++i;
            }
        }
    }
    
    // push back the leftovers
    while(i<sizeS1) {
        merged.push_back(s1[i]);
        ++i;
    }
    
    while(j<sizeS2) {
        merged.push_back(s2[j]);
        ++j;
    }

    return merged;
}

/*
You've created a new programming language, and now you've decided to add hashmap support to it. Actually you are quite disappointed that in common programming languages it's impossible to add a number to all hashmap keys, or all its values. So you've decided to take matters into your own hands and implement your own hashmap in your new language that has the following operations:

insert x y - insert an object with key x and value y.
get x - return the value of an object with key x.
addToKey x - add x to all keys in map.
addToValue y - add y to all values in map.
To test out your new hashmap, you have a list of queries in the form of two arrays: queryTypes contains the names of the methods to be called (eg: insert, get, etc), and queries contains the arguments for those methods (the x and y values).

Your task is to implement this hashmap, apply the given queries, and to find the sum of all the results for get operations.

Example

For queryType = ["insert", "insert", "addToValue", "addToKey", "get"] and query = [[1, 2], [2, 3], [2], [1], [3]], the output should be hashMap(queryType, query) = 5.

The hashmap looks like this after each query:

1 query: {1: 2}
2 query: {1: 2, 2: 3}
3 query: {1: 4, 2: 5}
4 query: {2: 4, 3: 5}
5 query: answer is 5
The result of the last get query for 3 is 5 in the resulting hashmap.



For queryType = ["insert", "addToValue", "get", "insert", "addToKey", "addToValue", "get"] and query = [[1, 2], [2], [1], [2, 3], [1], [-1], [3]], the output should be hashMap(queryType, query) = 6.

The hashmap looks like this after each query:

1 query: {1: 2}
2 query: {1: 4}
3 query: answer is 4
4 query: {1: 4, 2: 3}
5 query: {2: 4, 3: 3}
6 query: {2: 3, 3: 2}
7 query: answer is 2
The sum of the results for all the get queries is equal to 4 + 2 = 6.

Input/Output

[execution time limit] 0.5 seconds (cpp)

[input] array.string queryType

Array of query types. It is guaranteed that each queryType[i] is either "addToKey", "addToValue", "get", or "insert".

Guaranteed constraints:
1 ≤ queryType.length ≤ 105.

[input] array.array.integer query

Array of queries, where each query is represented either by two numbers for insert query or by one number for other queries. It is guaranteed that during all queries all keys and values are in the range [-109, 109].

Guaranteed constraints:
query.length = queryType.length,
1 ≤ query[i].length ≤ 2.

[output] integer64

The sum of the results for all get queries.

[C++] Syntax Tips

// Prints help message to the console
// Returns a string
string helloWorld(string name) {
    cout << "This prints to the console when you Run Tests" << endl;
    return "Hello, " + name;
}

*/
std::unordered_map<int, int> alterKeys(std::unordered_map<int, int> initialMap, int addToKey) {
    std::unordered_map<int, int> alteredMap;
    for(auto const & iter : initialMap) {
        auto key = iter.first + addToKey;
        alteredMap[key] = iter.second;
    }
    
    return alteredMap;
}

long long hashMap(std::vector<std::string> queryType, std::vector<std::vector<int>> query) {
    /*
    Sample tests: 15/15
    Hidden tests: 4/15
    Score: 153/300
    */
    // queryType: names of the methods (insert, get, ...)
    // query: the arguments for the methods (x, y)
    // return sum of the results for all the "get" queries.
    std::unordered_map<int, int> myMap;
    long long sum = 0;
    auto size = queryType.size();
    for(size_t i=0; i<size; ++i) {
        auto function = queryType[i];
        auto args = query[i];
        if(function == "insert") { // insert <args[0], args[1]>
            myMap[args[0]] = args[1];
        } else if(function == "get") { // getValue(args[0])
            auto value = myMap[args[0]];
            sum += value;
        } else if(function == "addToKey") { // add args[0] to all keys in the map!
            myMap = alterKeys(myMap, args[0]);
        } else if(function == "addToValue") { // add args[0] to all values in the map!
            for(auto & iter : myMap) {
                iter.second += args[0];
            }
        }
    }
    
    return sum;
}

bool anagramCheck(int a, int b) {
    std::unordered_map<int, int> occurMap; // <digit, #ofOccur>
    
    //cout << "a: " << a << " b: " << b << endl;
	
	if(a == b) {
		return true;
	} else if(a == 0 || b == 0) {
		return false;
	}
    
    int modular = 10;
    while(a != 0) {
        auto digit = a % modular;
        
        //cout << "digit: " << digit << endl;
        
        occurMap[digit]++;
        
        a -= digit;
        a /= modular;
    }
    
    while(b != 0) {
        auto digit = b % modular;
        
        occurMap[digit]--;
        
        b -= digit;
        b /= modular;
    }
    
    /*for(auto const & iter : occurMap) {
        cout << "<first, second>: " << iter.first << ", " << iter.second << endl;
    }*/
    
    for(auto const & iter : occurMap) {
        if(iter.second != 0) {
            return false;
        }
    }
    
    return true;
}

long long digitAnagrams(std::vector<int> a) {
    long long counter = 0;
    
    for(size_t i=0; i<a.size()-1; ++i) {
        for(size_t j=i+1; j <a.size(); ++j) {
            if(anagramCheck(a[i], a[j])) {
                //std::cout << "anagrams: " << a[i] << " <-> " << a[j] << endl;
                ++counter;
            }
        }
    }
    
    return counter;
}

}

#endif // _CODE_SIGNAL_TASKS_H_